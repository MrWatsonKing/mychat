# ################## Makefile

default:
	gcc climain.c client.c -lpthread -o clnt
	gcc sermain.c server.c list.c sqlitedb.c -lpthread -lsqlite3 -o srvr
clean:
	rm *.o

# ################### mychat-v1.1 更新日志:

# 已解决问题:

# 1.彻底解决了消息收发过程中产生的乱码问题
# 问题原因:
# 	read()函数将读取的消息写入缓冲区之后,并没有将有效数据后面紧跟的字节置为'\0',故对缓冲区直接进行字符串读取操作,可能会读取超过有效信息的部分,多出的部分就会变成乱码. 
# 解决办法:
# 	将有效信息之后紧跟的第一个字节置为'\0'字符,可以彻底解决read()函数造成的字符串接收乱码问题.

# 2.空白输入产生(null)广播消息的问题
# 问题原因:
# 	没有对输入的文本进行有效性检查,导致无效信息(只包含"\n")被发送.其他客户端接收到无效信息,就会显示(null).
# 解决办法:
# 	对输入内容进行有效性检查,缺乏有效信息的消息,将不予发送,并重新准备接收用户输入.

# 3.服务器不能正常退出,只能强制退出的问题
# 问题原因:
# 	没有为服务器设置合理的退出办法,每次只能强制退出,导致退出之后端口仍然被占用,服务器不能正常重建.
# 解决办法:
# 	为服务器设置单独的输入接收线程,当收到键盘输入:exit的时候,服务器释放所有资源然后正常退出.

# 4.日志生成被覆盖的问题
# 问题原因:
# 	没有对日志文件的名称进行差异化处理,导致每次开启程序,新的日志覆盖了旧的日志,并且一个客户端的日志覆盖了另一个客户端的日志.
# 解决办法:
# 	a.对日志文件名插入客户名进行差异化处理,防止不同客户端生成的日志相互覆盖;	
# 	b.对当天生成的日志文件,文件名上加入当天的日期,既方便查找,也不会覆盖.
# 	c.对聊天日志的格式进行了进一步的优化，采用hh:mm:ss msg\n 格式，相比之前更加的简洁清晰。

# 5.用户重复进入聊天房间自己和自己聊天的问题
# 问题原因:
# 	由于服务器规定进入聊天房间才能计入在线列表，所以删除了之前对重复登录进行检查的代码，而没有相应增加对重复进入聊天房间的检查代码。
# 解决办法:
# 	在用户进入聊天房间的第一时间，服务器根据用户名进行在线状态检查，如果用户已经进入房间，则向客户端发送重复登入提示然后结束针对该用户的聊天服务，如果用户没有进入房间，则发送登入成功消息，然后将用户加入在线列表并提供转发服务。

# 6.客户端缺乏帮助功能，新用户不了解软件功能和使用方法的问题
# 解决办法:
# 	增加了客户端帮助程序，在command:栏输入help，即可获得完整的命令列表和功能说明.

# 7.服务器测试提示语句过多，可能降低服务效率的问题
# 解决办法:
# 	注释了服务器代码中大部分已经测试通过的功能模块的提示语句。

# 8.用户login登录成功之后，仍然可以register，造成逻辑错误的问题
# 解决办法:
# 	a.注册部分，增加登录状态检查，如果已经登录，则不允许注册，提示需要先登出。
# 	b.添加登出功能。

# 9.文件传送乱码和中文文本显示不正常的问题
# 问题原因:
# 	文件传送乱码或中文文本显示不正常,两者本质上是一个问题,都是文件转发过程中发生了意外修改,以及对缓冲区读取方式不当造成的.
# 解决办法:
# 	a.服务器不再对客户消息作任何修改,停止对客户消息进行strtok(msg,"\n")或添加\n的操作.
# 	b.对所有缓冲区读取得到的内容,根据有效信息长度,将最后一个有效字节后面紧跟的第一个字节设为'\0',
# 就将缓冲区字节数组转换成为标准的'\0'结尾字符串,然后再调用任何格式化字符串操作,都能获得预期的效果.

# 待解决问题:

# 1.在公网通信需要进行ip解析的问题
# 2.客户端界面和友好操作的问题


# ###################### mychat-v1.2 更新日志

# 已解决问题:

# 1.文件传送机制方方面面存在重大逻辑缺陷和流程错误的问题

# 	问题原因:

# 	a.数据包缺乏统一格式,导致内容解析流程复杂;
# 	b.消息的来源/去向/单发/群发等必要信息获取不足;
# 	c.部分条件下对数据包过度解析甚至修改,增加服务器负担,且容易造成信息失真;
# 	d.在前版的文件收发机制下,文件收发命令可以单发或群发,但文件数据包的收发却始终是群发实现,属于严重逻辑错误;
# 	e.因为read()函数的返回次数不确定,所以通过数据包大小和文件大小来确定循环次数的方法,对接受端失效,引起接收循环次数不足,造成文件接收不完整和消息显示错误;
# 	f.发送客户端和接收客户端之间,缺乏协调同步机制,导致接受端还没有进入准备接收状态,发送端就已经发送消息完毕,从而引起数据丢失和消息显示错误.

# 	解决办法:

# 	a.定义统一的数据收发格式,服务器不再对消息内容进行解析和改动,只进行群发和定向转发.
# 	b.发送格式统一为@toname realmsg\n,接收格式统一为fromname:@toname realmsg\n.服务器对toname进行判断,针对toname不存在/存在/="."等三种情况,分别进行错误返回/单向转发/群发.若发送方不指定@toname,则发送端自动添加@.至消息头,@.表示群发.
# 	以上自定义消息协议,有效的解决了消息必要信息不足的问题,从而为更加精准/科学/有效的消息转发机制提供了可能.\
# 	c.在统一消息格式下,服务器的工作方式更加简单,只需要根据来源客户端cfd找到对应的fromname,然后添加fromname:至要转发的消息头部,再根据toname的情况进行针对性的返回或转发.
# 	d.在统一消息格式下,任何对话消息或文件流包,都会被添加fromname:@toname消息头,从而为所有数据流的正确定向提供了充分条件.指定接受人的文件流,将不会再被群发.
# 	e.重新定义文件收发的循环退出机制,发送和接收统一设定为死循环.发送方统计每一次实际发出的具体字节数,累计达到文件大小,则退出循环;接受方统计每一次实际接受到的具体字节数,累计达到文件大小,则退出循环.这样直接杜绝了文件还没有收发完毕就退出循环的bug.
# 	f.针对文件收发不同步导致信息丢失和消息显示错误的问题,分两种情况处理.
# 	第一种情况:
# 	对定向单发的文件流,收发双方开始收发操作之前,接收方必须先发送接收状态认证到发送方,然后发送方根据状态认证分别进行处理.如果状态认证为[verify]: OK.\n则表示获取文件size信息正常,可以进入收发循环;若状态认证为[verify]: NO.\n表示获取文件size失败,取消本次文件传输.
# 	收发循环开始后,每一次接收方都要发送接收状态认证,才可进行本次操作,若状态认证为[verify]: CC.\n则表示可以继续进行下方操作;若认证状态为[verify]: SS.\n则表示出现异常必须停止文件传输.
# 	经过收发状态认证之后,接收方始终会先一步进入准备接收状态,就可以直接避免因为时间滞后而没有接收到数据包的问题.发送方必须获得接收认证,才可发送文件流包,否则进入阻塞等待状态.
# 	以上收发方协调同步机制,清晰规范了文件收发对话流程,有效避免了文件收发不同步引起的数据丢失和显示错乱问题.
# 	第二种情况:
# 	对群发的文件流,发送方是唯一的,但是接收者是众多的,此时通过状态认证来实现的收发协调机制将失效.任何一个接收方的认证消息都可能解除发送方的阻塞状态,而发送方发送文件的时候,并不能保证所有的接收方都正确/及时地进入了接收状态.
# 	所以对于群发的文件,必须创建新的解决方案.可行的方法是文件上传,通过:upload $filepath语句,将本地文件上传至服务器,然后任何客户端都可以通过:download $filepath命令来下载文件至本地.这样就完美解决了共享文件的异步收发问题.


# 2.@toname之toname不在线,但文件传输依然被启动且进入阻塞状态的问题.

# 	问题原因:
# 	没有对toname进行在线状态检查

# 	解决方案:
# 	对toname进行在线状态检查之后,根据在线状态再决定是否开启文件传输和日志录入.



# 待解决问题:

# 1.共享文件上传至服务器,以及从服务器下载共享文件的问题.
# 2.在公网通信需要进行ip地址解析的问题
# 3.客户端界面和友好操作的问题
