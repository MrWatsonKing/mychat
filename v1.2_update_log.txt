mychat-v1.2 更新日志

已解决问题:

1.文件传送机制方方面面存在重大逻辑缺陷和流程错误的问题

	问题原因:

	a.数据包缺乏统一格式,导致内容解析流程复杂;
	b.消息的来源/去向/单发/群发等必要信息获取不足;
	c.部分条件下对数据包过度解析甚至修改,增加服务器负担,且容易造成信息失真;
	d.在前版的文件收发机制下,文件收发命令可以单发或群发,但文件数据包的收发却始终是群发实现,属于严重逻辑错误;
	e.因为read()函数的返回次数不确定,所以通过数据包大小和文件大小来确定循环次数的方法,对接受端失效,引起接收循环次数不足,造成文件接收不完整和消息显示错误;
	f.发送客户端和接收客户端之间,缺乏协调同步机制,导致接受端还没有进入准备接收状态,发送端就已经发送消息完毕,从而引起数据丢失和消息显示错误.

	解决办法:

	a.定义统一的数据收发格式,服务器不再对消息内容进行解析和改动,只进行群发和定向转发.
	b.发送格式统一为@toname realmsg\n,接收格式统一为fromname:@toname realmsg\n.服务器对toname进行判断,针对toname不存在/存在/="."等三种情况,分别进行错误返回/单向转发/群发.若发送方不指定@toname,则发送端自动添加@.至消息头,@.表示群发.
	以上自定义消息协议,有效的解决了消息必要信息不足的问题,从而为更加精准/科学/有效的消息转发机制提供了可能.\
	c.在统一消息格式下,服务器的工作方式更加简单,只需要根据来源客户端cfd找到对应的fromname,然后添加fromname:至要转发的消息头部,再根据toname的情况进行针对性的返回或转发.
	d.在统一消息格式下,任何对话消息或文件流包,都会被添加fromname:@toname消息头,从而为所有数据流的正确定向提供了充分条件.指定接受人的文件流,将不会再被群发.
	e.重新定义文件收发的循环退出机制,发送和接收统一设定为死循环.发送方统计每一次实际发出的具体字节数,累计达到文件大小,则退出循环;接受方统计每一次实际接受到的具体字节数,累计达到文件大小,则退出循环.这样直接杜绝了文件还没有收发完毕就退出循环的bug.
	f.针对文件收发不同步导致信息丢失和消息显示错误的问题,分两种情况处理.
	第一种情况:
	对定向单发的文件流,收发双方开始收发操作之前,接收方必须先发送接收状态认证到发送方,然后发送方根据状态认证分别进行处理.如果状态认证为[verify]: OK.\n则表示获取文件size信息正常,可以进入收发循环;若状态认证为[verify]: NO.\n表示获取文件size失败,取消本次文件传输.
	收发循环开始后,每一次接收方都要发送接收状态认证,才可进行本次操作,若状态认证为[verify]: CC.\n则表示可以继续进行下方操作;若认证状态为[verify]: SS.\n则表示出现异常必须停止文件传输.
	经过收发状态认证之后,接收方始终会先一步进入准备接收状态,就可以直接避免因为时间滞后而没有接收到数据包的问题.发送方必须获得接收认证,才可发送文件流包,否则进入阻塞等待状态.
	以上收发方协调同步机制,清晰规范了文件收发对话流程,有效避免了文件收发不同步引起的数据丢失和显示错乱问题.
	第二种情况:
	对群发的文件流,发送方是唯一的,但是接收者是众多的,此时通过状态认证来实现的收发协调机制将失效.任何一个接收方的认证消息都可能解除发送方的阻塞状态,而发送方发送文件的时候,并不能保证所有的接收方都正确/及时地进入了接收状态.
	所以对于群发的文件,必须创建新的解决方案.可行的方法是文件上传,通过:upload $filepath语句,将本地文件上传至服务器,然后任何客户端都可以通过:download $filepath命令来下载文件至本地.这样就完美解决了共享文件的异步收发问题.


2.@toname之toname不在线,但文件传输依然被启动且进入阻塞状态的问题.

	问题原因:
	没有对toname进行在线状态检查

	解决方案:
	对toname进行在线状态检查之后,根据在线状态再决定是否开启文件传输和日志录入.



待解决问题:

1.共享文件上传至服务器,以及从服务器下载共享文件的问题.
2.在公网通信需要进行ip地址解析的问题
3.客户端界面和友好操作的问题
